[
["index.html", "Relazione di tesi: La serie di Fourier e una sua applicazione alla grafica Introduzione", " Relazione di tesi: La serie di Fourier e una sua applicazione alla grafica Matteo Bramardi, candidato Prof. Paolo Boggiatto, relatore 01 luglio 2020 Introduzione L’idea per l’argomento della tesi nasce dal video But what is a Fourier series? From heat flow to circle drawings pubblicato su YouTube da Grant Sanderson, noto come 3Blue1Brown. Rimasto colpito dal fascino estetico delle animazioni e dalla loro squisita immediatezza, ho deciso di approfondirne i fondamenti teorici. Il cuore della tesi è la presentazione che, oltre ad una dissertazione teorica del tema, ripropone le suddette animazioni, da me ricreate ed adattate. La presentazione è affinata per agevolarne la comprensione attraverso l’interazione con diversi suoi elementi e aspira ad essere un esempio di applicazione delle tecnologie informatiche a fini didattici. Essa è il risultato di quasi un anno di lavoro e studio personale e concretizza la mia idea di presentare la matematica in modo coinvolgente e con l’ausilio di visualizzazioni grafiche di forte impatto e semplice interpretazione. "],
["lavoro.html", "Capitolo 1 Fasi del lavoro 1.1 Primi prototipi 1.2 Ricerca teorica 1.3 Animazioni 1.4 Presentazione", " Capitolo 1 Fasi del lavoro 1.1 Primi prototipi Dopola visione del video sopracitato nel mese di luglio 2019, ho realizzato il primo prototipo dell’animazione principale in JavaScript seguendo alcuni tutorial di The Coding Train. A dicembre dello stesso anno ho poi riscritto il precedente prototipo in Java e ne ho ampliato le funzionalità. Ciò mi ha permesso di familiarizzare con i vari algoritmi impiegati nella generazione delle informazioni utili alla visualizzazione dell’animazione e con la loro implementazione. 1.2 Ricerca teorica Già nel mese di dicembre 2019 mi ero approcciato allo studio della trasformata di Fourier e di una sua applicazione alla compressione delle immagini con il metodo JPEG lossy - basato sulla trasformata discreta del coseno - con lo scopo di produrre un trittico di poster sull’argomento, parte della prova di esame del corso di Analisi Matematica 3. La fase di ricerca teorica vera e propria ha avuto inizio nel mese di marzo 2020 e, su indicazione del mio relatore Prof. Paolo Boggiatto, ha riguardato principalmente lo studio approfondito di alcune sezioni del libro Fourier Analysis and Applications di C. Gasquet e P. Witomski: nello specifico, il capitolo II - i segnali periodici e la serie di Fourier -, la lezione 8 del capitolo III - la trasformata discreta di Fourier - e le lezioni 17, 18 e 19 del capitolo VI - la trasformata di Fourier di funzioni integrabili, la trasformata inversa e lo spazio \\(\\mathcal{S}(\\mathbb{R})\\). La questione centrale della tesi, alla base del funzionamento dell’animazione, riguarda la possibilità di scrivere una funzione \\(f: \\mathbb{R} \\longrightarrow \\mathbb{C}\\) periodica di periodo \\(a\\) come \\[f(t)=\\sum_{n=-\\infty}^{+\\infty}c_{n}e^{2\\pi in \\frac{t}{a}} \\ ,\\] dove \\(c_n \\in \\mathbb{C}\\) e \\(n \\in \\mathbb{Z}\\), sotto minime ipotesi sulla funzione \\(f\\). Inoltre, durante lo sviluppo del software, si è rivelato utile affrontare il tema delle curve di Bèzier, in particolare delle polybézier - ovvero di una curva di Bèzier continua definita a tratti. Per potenziare le mie conoscenze in materia, ho fatto uso del libro A Primer on Bézier Curves, disponibile online, che mi ha fornito le basi necessarie per manipolare tali oggetti da un punto di vista informatico. Prima della fase di programmazione si è poi resa necessaria una ricerca degli strumenti informatici più adatti. Una discussione degli strumenti adottati e del loro impiego è consultabile al capitolo dedicato. 1.3 Animazioni Terminata la raccolta e lo studio delle informazioni necessarie, ha potuto avere inizio la programmazione delle animazioni in maniera più accurata rispetto ai primi prototipi. Il loro sviluppo è avvenuto in JavaScript, facendo ampio uso delle librerie open source p5.js, per il creative coding, e complex.js, per la gestione dei numeri complessi. Ciò ha permesso, a differenza di un semplice video, di rendere le animazioni interattive, andando così a potenziare il legame con lo spettatore che si trasforma quindi in utente attivo. L’obiettivo delle animazioni è quello di agevolare la comprensione dei concetti teorici tramite una loro visualizzazione immediata e metterne in evidenza le sfaccettature più nascoste, andando ad affiancare ed assistere l’ingegno e le capacità immaginative dei loro fruitori. Molta attenzione è stata riposta nella loro estetica, in quanto ritengo che l’aspetto artistico non sia affatto secondario al contenuto, ma piuttosto funzionale a quest’ultimo, poiché in grado di avvicinare e coinvolgere lo spettatore-utente instaurando una connessione emotiva e sensoriale più forte. La filosofia alla base di questo approccio deriva sicuramente dalla visione artistica del video originale. Tuttavia, è stata ampiamente influenzata anche dagli Elementi di Euclide a colori, ovvero un’edizione del celebre libro di geometria in cui simboli e figure colorate sostituiscono le lettere, e dal pensiero del suo autore, Oliver Byrne, che ho avuto modo di apprezzare durante il corso di Storia della Matematica Antica e Moderna. Ho infine curato l’accessibilità, ovvero la facilità di utilizzo, e la portabilità, cioè la corretta visualizzazione e fruizione su diversi tipi di dispositivi, principi chiavi per garantire all’utente un’esperienza fluida e priva di ostacoli o barriere di carattere tecnico. 1.4 Presentazione La presentazione è stata realizzata con Reveal.js, un framework open source per presentazioni HTML a cui ho apportato diverse personalizzazioni. Ciò mi ha permesso di integrare perfettamente (ovvero seamlessly in inglese) le animazioni nell’ambiente della presentazione, senza richiedere all’utente operazioni aggiuntive. Inoltre, il file HTML può essere visualizzato da un’ampia gamma di dispositivi tramite un qualsiasi browser e le ridotte dimensioni del file lo rendono ideale per la distribuzione online. La filosofia che mi ha guidato nella creazione delle slide è la stessa discussa nel precedente paragrafo: accessibilità e piacevolezza estetica hanno costituito il fondamento su cui sviluppare il contenuto e il mezzo con cui esaltarlo, ma senza in alcun modo prevaricarlo. In tal senso, diversi accorgimenti sono stati adottati per affinare l’esperienza dell’utente finale. Nel capitolo successivo verrà fornito un commento di carattere teorico alla presentazione. "],
["commento.html", "Capitolo 2 Commento alla presentazione 2.1 Segnali trigonometrici 2.2 Segnali periodici e serie di Fourier 2.3 Rappresentazione puntuale", " Capitolo 2 Commento alla presentazione La presentazione segue per sommi capi le prime due lezioni del capitolo II del libro Fourier Analysis and Applications di C. Gasquet e P. Witomski, oggetto della ricerca. Le slide sono autonome da un punto di vista teorico e possono essere utilizzate parallelamente al libro sopracitato come strumento supplementare per l’apprendimento. Funzionalità Le animazioni sono integrate nella presentazione ed è possibile interagire con esse; formule, teoremi (o corollari) ed esempi sono demarcati rispettivamente con colore azzurro, verde e giallo per un più semplice riconoscimento; formule e teoremi vengono visualizzati in una piccola scheda al passaggio o click del mouse sui rispettivi riferimenti, rendendo immediata la loro consultazione, mentre un ulteriore click su tali schede conduce alla slide in cui sono stati introdotti; 2.1 Segnali trigonometrici Diciamo polinomi trigonometrici le funzioni del tipo \\[\\begin{equation} p(t) = \\sum_{n=-N}^N c_n e^{2 i \\pi n \\textstyle \\frac {t}{a}} \\ , \\tag{2.1} \\end{equation}\\] dove \\(a,t \\in \\mathbb{R}, \\ c_n \\in \\mathbb{C}\\). \\(p(t)\\) ha periodo \\(a\\) e grado minore o uguale a \\(N\\). Seguono immediatamente due animazioni per visualizzare un polinomio trigonometrico. Nella prima è possibile - tramite rotella del mouse o trascinamento verticale su schermo - costruire progressivamente un polinomio trigonometrico aumentandone il grado e, di conseguenza, il numero di addendi. Il primo elemento visibile è il coefficiente \\(c_0\\), ovvero un numero complesso. Gli altri elementi sono costituiti dal coefficiente complesso \\(c_n\\) moltiplicato per \\(e_n(t)=e^{2\\pi in\\frac{t}{a}}\\) ovvero la curva chiusa complessa con supporto la circonferenza unitaria, percorsa con frequenza \\(n\\). Poiché la moltiplicazione di due numeri complessi può essere interpretata come il multiplo di una rotazione, \\(c_n \\cdot e_n(t)\\) rappresenta la curva chiusa con supporto una circonferenza di raggio \\(|c_n|\\) e una fase \\(arg(c_n)=\\theta_n\\) (dove \\(c_n=r_{n}e^{i\\theta_n}\\)) rispetto alla curva \\(|c_n| \\cdot e_n(t)\\). Le varie componenti del tipo \\(c_n \\cdot e_n(t)\\) possono essere sommate con la definizione usuale di somma in campo complesso, ottenendo una curva che rappresenta proprio il polinomio trigonometrico. Nella seconda animazione è possibile - sempre tramite rotella del mouse o trascinamento verticale su schermo - rivelare l’asse della variabile \\(t\\) per mezzo di una rotazione tridimensionale, visualizzando il polinomio trigonometrico nello spazio \\(\\mathbb{R} \\times \\mathbb{C}\\). Introduciamo quindi \\(T_n\\), spazio vettoriale (di dimensione \\(2N-1\\)) dei polinomi trigonometrici \\(p(t)\\) di grado minore o uguale a \\(N\\), dotato del prodotto scalare \\[(p,q) = \\int_{0}^{a} p(t) \\overline{q}(t)dt \\ .\\] Da \\((p,n)=a\\cdot c_n\\) ricaviamo quindi la formula di Fourier \\[\\begin{equation} c_n=\\frac{1}{a} \\int_{0}^{a}p(t)e^{-2 i \\pi n \\textstyle \\frac {t}{a}}dt \\ . \\tag{2.2} \\end{equation}\\] Ci poniamo dunque la domanda fondamentale: se \\(f: \\mathbb{R} \\longrightarrow \\mathbb{C} \\ \\) è una funzione arbitraria di periodo \\(a\\), possiamo trovare una decomposizione di \\(f\\) della forma \\[\\begin{equation} f(t) = \\sum c_n e^{2 \\pi in\\textstyle \\frac{t}{a}} \\ , \\tag{2.3} \\end{equation}\\] sotto minime ipotesi su \\(f\\) ? 2.2 Segnali periodici e serie di Fourier In un celebre articolo del 1807, Joseph Fourier afferma che la risposta a tale domanda è affermativa, a patto che siano consentite somme infinite. È possibile ridefinire questa risposta con gli strumenti della matematica moderna. Per farlo, introduciamo lo spazio \\[L_{p}^2(0,a)= \\{ f:\\mathbb{R} \\longrightarrow \\mathbb{C} \\ : \\ f \\ \\text{ ha periodo } a \\text{ e } \\int_{0}^{a}|f(t)|^2dt &lt; +\\infty\\bigg\\}\\] che, dotato delle usuali operazioni, è uno spazio vettoriale. Definiamo quindi il prodotto scalare \\[(f,g) = \\int_{0}^{a} f(t) \\overline{g}(t)dt \\ ,\\] e la norma associata \\[ \\Vert f \\Vert_2 = \\left( \\int_{0}^{a} |f(t)|^2 dt \\right) ^{\\textstyle \\frac{1}{2}} \\ .\\] Per rispondere alla domanda fondamentale occorre trovare l’elemento \\(f_N\\) nel sottospazio \\(T_n\\) di \\(L_{p}^{2}(0,a)\\) che ha la minima distanza da \\(f\\). Se esiste, lo chiamiamo la miglior approssimazione di \\(f\\) in \\(T_{n}\\). La soluzione è fornita dal seguente teorema: Teorema Esiste un unico polinomio trigonometrico \\(f_N\\) in \\(T_n\\) tale che \\[ \\Vert f - f_N \\Vert _{2} = \\min_{p \\in T_N} \\Vert f - p \\Vert _{2} \\] Questo polinomio è dato da \\[\\begin{equation} f_{N}(t)=\\sum_{n=-N}^{N} c_{n}e^{2\\pi in \\textstyle \\frac {t}{a}} \\ , \\tag{2.4} \\end{equation}\\] dove \\[\\begin{equation} c_n=\\frac{1}{a} \\int_{0}^{a}f(t)e^{-2 i \\pi n \\textstyle \\frac {t}{a}}dt \\ . \\tag{2.5} \\end{equation}\\] Per qualunque \\(f \\in L_{p}^{2}(0,a) \\ \\), vale poi la disuguaglianza \\[ \\sum_{n=-\\infty}^{\\infty} |c_n|^{2} &lt; + \\infty \\] e quindi \\[ c_n(f) \\rightarrow 0 \\ \\text{ per } \\ |n| \\rightarrow + \\infty \\ . \\] Il passaggio successivo consiste nello studio della convergenza. Grazie ad un esempio animato, è possibile osservare come l’approssimazione, data da una somma di seni, tenda alla funzione onda quadra: è possibile - tramite rotella del mouse o trascinamento verticale su schermo - aumentare in numero di addendi nella somma e, quindi, migliorare l’approssimazione. In conclusione, è possibile scrivere: \\[\\begin{equation} f(t) = \\sum_{n= - \\infty}^{+ \\infty} c_n e^{2 i \\pi n \\textstyle \\frac {t}{a}} \\ . \\tag{2.6} \\end{equation}\\] Si noti che questa è un’equivalenza nella norma di \\(L_{p}^{2}(0,a)\\) e non significa che, per qualunque valore di \\(t\\), \\(f(t)\\) sia uguale alla somma della serie. 2.3 Rappresentazione puntuale Poiché una funzione impiegata in computazione numeriche è necessariamente valutata solo in un numero finito di punti, è importante determinare se la formula (2.6) possa esprimere un’equivalenza ad un dato punto \\(t\\). Questo è il problema della convergenza puntuale. Per risolverlo, ci dovremo estendere oltre \\(L^2_p(0,a)\\). Dalla caratterizzazione dell’integrale di Lebesgue \\[ f \\text{ è Lebesgue-integrabile su } I \\ \\iff \\ \\int_{I}|f(t)|dt &lt; +\\infty \\] segue immediatamente che i coefficienti di Fourier esistono se e solo se \\(f\\) è integrabile su \\((a,b)\\). Introduciamo la notazione \\[L_{p}^{1}(0,a) = \\left\\{ f : \\mathbb{R} \\longrightarrow \\mathbb{C} \\ : \\ f \\text{ ha periodo } a \\text{ e } \\int_{0}^{a}|f(t)|dt &lt; +\\infty \\right\\} \\ .\\] e notiamo che \\(L_p^2(0,a) \\subset L_p^1(0,a)\\), quindi \\(f \\in L_p^1(0,a)\\) è una condizione meno restrittiva di \\(f \\in L_p^2(0,a)\\). Al momento non sappiamo se la serie \\(\\sum_{n=-\\infty}^{+\\infty}c_n(f)e^{2\\pi in\\frac{t}{a}}\\) converga e, in caso di convergenza, non conosciamo il valore del limite. Una condizione necessaria ma non sufficiente è che \\[c_n \\rightarrow 0 \\text{ per } |n| \\rightarrow + \\infty \\ .\\] Tale condizione è verificata per \\(f \\in L_p^2(0,a)\\) e rimane vera anche per \\(f \\in L_p^1(0,a)\\) Teorema di Riemann-Lebesgue Sia \\((a,b)\\) un intervallo limitato e sia \\(f\\) integrabile su \\((a,b)\\). Allora l’integrale \\[ I_n = \\int_{a}^{b}f(x)e^{2 \\pi in x} dx \\rightarrow 0 \\ \\text{ per } \\ |n| \\rightarrow + \\infty \\] Un altro importante risultato è riassunto dal teorema di Dirichlet, che mostra come la convergenza della serie di Fourier di \\(f\\) in un punto \\(t_0\\) dipende esclusivamente dal comportamento di \\(f\\) in un intorno di \\(t_0\\). Teorema di Dirichlet Sia \\(f \\in L^1_p(0,a)\\). Se esistono i limiti \\(f(t+)\\) e \\(f(t-)\\) in un punto \\(t_0\\) ed esistono le derivate destra e sinistra in \\(t_0\\), allora \\[f_N(t_0) \\rightarrow \\frac{1}{2} \\big[ f(t_0+) + f(t_0-) \\big] \\ \\text{ per } \\ N \\rightarrow +\\infty \\ .\\] Se \\(f\\) è continua in \\(t_0\\), \\(f_N(t_0) \\rightarrow f(t_0)\\). È infine possibile ricavare delle informazioni in merito alla convergenza uniforme: Proposizione Se \\(f \\in L^2_p(0,a)\\) e i suoi coefficienti di Fourier soddisfano \\[ \\sum_{n=-\\infty}^{\\infty} |c_n| &lt; + \\infty \\ ,\\] allora \\(f\\) è uguale q.o. ad una funzione continua \\(\\tilde f\\) e la serie di Fourier di \\(f\\) converge uniformemente a \\(\\tilde f\\) su \\(\\mathbb{R}\\). In chiusura, vengono proposte le due animazioni riassuntive che riguardano un peculiare esempio: la prima, la più importante di tutta la presentazione, mostra la convergenza puntuale alla funzione \\(f\\) della sua serie di Fourier. È possibile - tramite rotella del mouse o trascinamento verticale su schermo - migliorare l’approssimazione data dalla somma parziale \\(N\\)-esima della serie di Fourier, facendo variare \\(N\\). È inoltre visibile, nella parte superiore, lo spettro del segnale periodico \\(f\\), definito dall’insieme di coppie \\((n/a,c_n), \\ n \\in \\mathbb{Z}\\) dove \\(c_n\\) è l’\\(n\\)-esimo coefficiente di Fourier di \\(f\\). la seconda mette in evidenza, tramite la scomposizione di \\(f(t)\\) in \\(f(t)=u(t)+iv(t)\\), la continuità di \\(f\\) e la sua appartenenza a \\(L^1_p(0,a)\\); "],
["software.html", "Capitolo 3 Software 3.1 Animazioni 3.2 Presentazione", " Capitolo 3 Software Questo capitolo è dedicato ad una discussione dettagliata di alcune delle più interessanti tecniche informatiche e dei programmi impiegati nella realizzazione della presentazione e delle animazioni. Il codice è interamente disponibile su GitHub. 3.1 Animazioni Le animazioni sono scritte in JavaScript e integrate in una pagina HTML. Per facilitare e velocizzare lo sviluppo, ho fatto ampio uso di p5.js, una libreria grafica open source per il creative coding, che offre una varietà di funzioni per la rappresentazione di costruzioni geometriche, il rendering e la manipolazione del DOM. Ho inoltre implementato diverse funzionalità per ottimizzare la gestione di alcuni aspetti delle animazioni. 3.1.1 Sistema di coordinate Data la peculiarità del sistema di coordinate a schermo utilizzato da p5.js (contraddistinto dall’origine posizionata nell’angolo in alto a sinistra dello schermo e dall’asse \\(y\\) invertito, come schematizzato in figura) si è reso necessario trovare un metodo per gestire la conversione in sistema di coordinate cartesiane. Quest’ultimo viene centrato e scalato in base all’altezza e alla larghezza della finestra contenitore e riconfigurato al ridimensionamento della stessa. La funzione toCartesian - responsabile della conversione da coordiate a schermo a coordinate cartesiane - tiene conto della dimensione della finestra, informazione contenuta in descaleFactor, e della posizione del centro della finestra: function toCartesian(x, y) { let cx = (x - xOrigin) * descaleFactor; let cy = (yOrigin - y) * descaleFactor; return createVector(cx, cy); } Lo stesso vale per la funzione inversa, che converte le coordinate cartesiane in coordinate a schermo: function toScreenCoord(x, y) { let sx = x * scaleFactor + xOrigin; let sy = yOrigin - y * scaleFactor; return createVector(sx, sy); } 3.1.2 Barra del progresso La barra del progresso (o progress bar) è un importante strumento di accessibilità e restituisce un feedback in merito al progresso possibile nell’interazione da parte dell’utente con l’animazione. La barra è posizionata sul lato destro dello schermo e monitora il comportamento dell’utente, attivandosi solo durante un’interazione e scomparendo dopo qualche secondo, per non interferire con il resto dell’animazione. È inoltre accompagnata da un’icona di un mouse, da me disegnata, che comunica all’utente, con delle apposite frecce pulsati, le azioni possibili. 3.1.3 La serie di Fourier Per rappresentare la serie di Fourier di una funzione periodica \\(f(t)\\) occorre definire con precisione la funzione - in modo che sia anche semplice da replicare graficamente - e calcolarne i coefficienti di Fourier. 3.1.3.1 Polybézier Il mezzo ideale per definire la funzione \\(f(t)\\) si è rivelato essere la polybézier. Una polybézier, o curva di Bézier composta, è una curva di Bézier definita a tratti e continua, vale a dire una concatenazione di curve di Bézier. In particolare, si prenderà in esame il caso di una concatenazione di curve di Bézier cubiche, ovvero il tracciato percorso dalla curva di parametrizzazione \\[\\begin{equation} \\mathbf{B}(t)=\\mathbf{P}_0(1-t)^3+3\\mathbf{P}_1t(1-t)^2+2\\mathbf{P}_2t^2(1-t)+\\mathbf{P}_3t^3 \\ , \\ t \\in [0,1] \\ . \\tag{3.1} \\end{equation}\\] La curva passa per i punti \\(\\mathbf{P}_0\\) e \\(\\mathbf{P}_3\\), ma non per i punti \\(\\mathbf{P}_1\\) e \\(\\mathbf{P}_2\\) che sono di controllo e forniscono informazioni direzionali. Il modo più semplice per comprendere la sua natura è visualizzarla: Una polybézier cubica è formata da un numero \\(M \\in \\mathbb{N}\\) di curve \\(\\mathbf{B}^j(t), \\ t \\in [0,1], \\ j=0,...,M-1\\) tali che \\(\\mathbf{B}^j(1)=\\mathbf{B}^{j+1}(0)\\). La curva risulterà chiusa se \\(\\mathbf{B}^0(0)=\\mathbf{B}^{M-1}(1)\\). Ho disegnato le curve con Inkscape, un editor grafico vettoriale open source. Il file generato - di formato SVG - può essere aperto con un semplice editor di testo e, al suo interno, ho identificato le coordinate dei punti. Ho poi scritto delle funzioni JavaScript per trasformare una stringa testuale in coordinate numeriche, trovare le coordinate di un punto \\(\\mathbf{P}(t)\\) giacente sulla curva dato \\(t\\) getPoint(p0, p1, p2, p3, t) { let x = p0.x * pow(1 - t, 3) + 3 * p1.x * t * pow(1 - t, 2) + 3 * p2.x * pow(t, 2) * (1 - t) + p3.x * pow(t, 3); let y = p0.y * pow(1 - t, 3) + 3 * p1.y * t * pow(1 - t, 2) + 3 * p2.y * pow(t, 2) * (1 - t) + p3.y * pow(t, 3); return new Complex(x, y); } e infine campionare \\(N\\) punti lungo la polybézier, distanziati equamente nella variabile \\(t \\in [0,1]\\): samplePoints(N) { let s = 1.000000 / N; let M = this.points.length / 3; let sampledPoints = []; for (let j = 0; j &lt; M; j++) { let points = { p0: this.points[3 * j], p1: this.points[1 + 3 * j], p2: this.points[2 + 3 * j], p3: this.points[(3 + 3 * j) % this.points.length] }; for (let k = 0; k &lt; N; k++) { sampledPoints[k + j * N] = this.getPoint(points.p0, points.p1, points.p2, points.p3, k * s); } } return sampledPoints; } 3.1.4 La trasformata discreta di Fourier Non potendo computare esplicitamente i coefficienti di Fourier con l’integrale \\[ c_n=\\frac{1}{a} \\int_{0}^{a}f(t)e^{-2 i \\pi n \\textstyle \\frac {t}{a}}dt \\ , \\] sono ricorso alla trasformata discreta di Fourier. Per farlo, è necessario assumere che la funzione \\(f(t)\\), di cui si vogliono calcolare i coefficienti, sia periodica di periodo \\(a\\) e che \\(N\\) dei suoi valori siano equamente distanziati sul periodo: \\[f \\bigg( k\\frac{a}{N} \\bigg)=y_{k} \\ , \\ \\ k=0,1,2,..., N-1 \\ .\\] Pertanto, si assume che il segnale \\(f(t)\\) sia campionato a tempi equamente distanziati di \\(\\frac{a}{N}\\) unità. Si assume inoltre che la serie di Fourier converga puntualmente a \\(f\\) e che nei punti di discontinuità \\[f(t)=\\frac{1}{2}\\big(f(t+)+f(t-)\\big) \\ .\\] Con la formula del trapezio, si ottiene un’approssimazione dei coefficienti di Fourier della funzione \\(f\\): \\[\\begin{equation} c&#39;_n=\\frac{1}{N}\\sum_{k=0}^{N-1}y_{k}e^{-2\\pi in\\frac{k}{N}} \\tag{3.2} \\end{equation}\\] Tradotto in termini informatici, la funzione responsabile del computo della trasformata discreta può essere così espressa: function dft(y) { const Y = []; const N = y.length; for (let n = 0; n &lt; N; n++) { let sum = new Complex(0, 0); for (let k = 0; k &lt; N; k++) { const phi = (- TWO_PI * k * n) / N; const c = new Complex(cos(phi), sin(phi)); sum.add(y[k].mult(c)); } sum = sum.div(N); let freq = n; let amp = sum.amp(); let phase = sum.phase(); Y[n] = { freq, amp, phase }; } return Y; } Applicando questo risultato ad una polybézier chiusa e composta da \\(M\\) curve di Bézier cubiche \\(\\mathbf{B}^j(t), \\ t \\in [0,1], \\ j=0,...,M-1\\), si ottiene: \\[\\begin{equation} c&#39;_n=\\frac{1}{M\\cdot N&#39;}\\sum_{j=0}^{M-1}\\sum_{k=0}^{N&#39;-1}\\mathbf{B}^{j}\\bigg(\\frac{k}{N&#39;}\\bigg)e^{-2\\pi in \\textstyle \\frac{j\\cdot N&#39;+ k}{M\\cdot N}} \\tag{3.3} \\end{equation}\\] dove \\(N&#39;\\) è il numero di punti campionati per ogni curva di Bézier che compone la polybébezier. 3.1.5 La rappresentazione della serie di Fourier Data la funzione \\(f(t)\\), ovvero la polybézier, e i coefficienti della serie di Fourier associata, computati con una trasformata discreta di Fourier, si può procedere alla rappresentazione grafica della serie. Una funzione si occupa di calcolare i punti del percorso tracciato al variare del tempo (time \\(\\in [0,2\\pi]\\)) e dati N coefficienti: function epicycles(time) { let N = fourier.length; let x = 0; let y = 0; for (let n = 0; n &lt; N; n++) { let prevx = x; let prevy = y; let freq = fourier[n].freq; let radius = fourier[n].amp; let phase = fourier[n].phase; x += radius * cos(freq * time + phase); y += radius * sin(freq * time + phase); ellipse(prevx, prevy, radius * 2); line(prevx, prevy, x, y); } return createVector(x, y); } I punti sono quindi salvati in un vettore (path) e uniti per formare il percorso: for (let i = 0; i &lt; path.length - 1; i ++) { line(path[i].x, path[i].y, path[i+1].x, path[i+1].y); } 3.2 Presentazione Come già spiegato in un precedente capitolo, le slide sono state create attraverso il framework per presentazioni HTML Reveal.js, modificato e personalizzato per meglio adattarsi alla visione artistica generale del progetto. Reveal.js permette di scrivere la presentazione usando il noto linguaggio di markup HTML. Questo approccio offre numerosi vantaggi: la portabilità del file su molti dispositivi, la compattezza del file e la possibilità di una semplice diffusione online. Inoltre, l’aspetto estetico può essere controllato tramite un apposito style sheet CSS in modo rapido e preciso. La scelta è ricaduta su questo approccio per la necessità di integrare fluidamente le animazioni. Reveal.js consente infatti di visualizzare pagine web sullo sfondo delle slide; ciò mi ha permesso di collegare i file HTML contententi le animazioni. &lt;!-- Convergenza --&gt; &lt;section data-background-iframe=&quot;https://bradwave.github.io/thesis/animations/s4-animation.html&quot; data-preload data-auto-animate&gt; &lt;h4&gt;2.2.1 Convergenza dell&#39;approssimazione $ $&lt;/h4&gt; &lt;hr&gt; &lt;p style=&quot;margin-top: -1%;&quot;&gt; Cosa succede a $f_N$ per $N \\rightarrow + \\infty$ ? &lt;/p&gt; &lt;blockquote class=&quot;example&quot; style=&quot;width: 80%; margin-top: 5px; margin-bottom: 5px; position: relative;&quot; data-id=&quot;block&quot;&gt; &lt;div class=&quot;fragment fade-down&quot; data-fragment-index=&quot;2&quot; style=&quot;position: absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;&quot;&gt; $$ \\text{approssimata da: } \\ f_N(t)=\\frac{4}{\\pi} \\left( sin(t) + \\frac{1}{3}sin(3t) + \\frac{1}{3}sin(5t) + ... \\right) $$ &lt;/div&gt; &lt;div class=&quot;fragment fade-down&quot; data-fragment-index=&quot;1&quot;&gt; &lt;div class=&quot;fragment fade-out&quot; data-fragment-index=&quot;2&quot; style=&quot;position: relative; margin-left: auto; margin-right: auto; left: 0; right: 0;&quot;&gt; $$ \\textit{Esempio: } \\ f(t) = \\begin{cases} +1, &amp; \\text{se $ \\ 0 \\le t \\lt \\pi $} \\\\ -1, &amp; \\text{se $ \\ \\pi \\le t \\lt 2 \\pi $} \\end{cases} $$ &lt;/div&gt; &lt;/div&gt; &lt;/blockquote&gt; &lt;/section&gt; Come visibile in questo esempio, l’attributo data-background-iframe definisce il link all’animzione; il titolo della slide è contenuto in un header, il testo nei paragrafi e il blockquote racchiude invece il testo dell’esempio. La classe fragment consente invece la comparsa graduale degli elementi. Le formule matematiche vengono visualizzate grazie al display engine MathJax. "],
["bibliografia.html", "Bibliografia", " Bibliografia C. Gasquet e P. Witomksi, Fourier Analysis and Applications, 1a ed., New York, NY, Springer, 1999. 3Blue1Brown, But what is a Fourier series? From heat flow to circle drawings, su YouTube, 2019. Pomax, A Primer on Bézier Curves, su github.com, accesso nel 2020. W. Rudin, Real and Complex Analysis, Singapore, McGraw Hill Book Co, 1987. E. Oran Briigham, The FFT and its Applications, Englewood Clifs, Prentice-Hall, 1988. S. W. Smith, The Scientist and Engineer’s Guide to Digital Signal Processing, California Technical Pub, 1997. O. Byrne, The First Six Books of Euclid, Londra, William Pickering, 1847. Documentazioni p5.js, su p5js.org reveal.js, su revealjs.com Complex.js, su github.com/infusion/Complex.js/ MathJax, su www.mathjax.org MathJax basic tutorial and quick reference, su math.meta.stackexchange.com/ Y. Xie, Bookdown: Authoring Books and Technical Documents with R Markdown, 2020. Y. Xie, Bookdown: Authoring Books and Technical Documents with R Markdown, Boca Raton, Florida, Chapman e Hall/CRC, 2016 Y. Xie, J. J. Allaire e G. Grolemund, R markdown: The definitive guide, Boca Raton, Florida, Chapman e Hall/CRC, 2018. "]
]
